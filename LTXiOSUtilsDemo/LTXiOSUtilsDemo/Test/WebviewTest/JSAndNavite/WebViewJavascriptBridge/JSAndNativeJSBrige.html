<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no">
    <title>WebViewJavascriptBridge</title>
</head>

<body>
    <p>调用Native方法</p>
    <button onclick="action()">调用</button>

</body>
<script>
    function setupWebViewJavascriptBridge(callback) {
        if (window.WebViewJavascriptBridge) {
            return callback(WebViewJavascriptBridge);
        }
        if (window.WVJBCallbacks) {
            return window.WVJBCallbacks.push(callback);
        }
        window.WVJBCallbacks = [callback];
        var WVJBIframe = document.createElement('iframe');
        WVJBIframe.style.display = 'none';
        WVJBIframe.src = 'https://__bridge_loaded__';
        document.documentElement.appendChild(WVJBIframe);
        setTimeout(function () {
            document.documentElement.removeChild(WVJBIframe)
        }, 0)
    }

    function action() {
        console.log("调用原生")
        var params = {
            'title': '测试分享的标题',
            'content': '测试分享的内容',
            'url': 'http://www.baidu.com'
        };

        // setupWebViewJavascriptBridge
        WebViewJavascriptBridge.callHandler('callForJS', params, function (response) {
            alert(response);
        });
    }

     // setupWebViewJavascriptBridge主动调一次的目的除了注册方法之外，还主动与Native通信一下，使Native注入js，生成WebViewJavascriptBridge这个属性，否则不可以使用WebViewJavascriptBridge这个属性调用Native方法
    setupWebViewJavascriptBridge(function (bridge) {
        bridge.registerHandler('callForNative', function (data, responseCallback) {
            console.log("callForNative:" + JSON.stringify(data))
            responseCallback("来自JS的回复")
        })
    })
</script>

</html>
